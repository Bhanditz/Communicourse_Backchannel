package CommunicationProtocol

import CommunicationProtocol.Chatroom.{Broadcast, ChatroomMessage}
import Quiz.QuizBotLanguage
import Quiz._
import BotInstructions._
import Traits._
import akka.actor.ActorRef
import akka.pattern.ask
import akka.util.Timeout

import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global._
import scala.util.parsing.combinator._
import scala.collection.immutable.StringOps
import scala.concurrent.ExecutionContext
/**
  * Created by robertMueller on 15.02.17.
  */
object Protocol {

  def messageCheck(clientMessage: ClientMessage,botLang: BotLanguage, bot: ActorRef, sender: ActorRef): Either[ChatroomMessage, Any] = {
      val botCommandPosition = extractMessageForBotPos(clientMessage.message)
      //evertything after hey_arjen
      if(botCommandPosition >= 0){
        val command =  clientMessage.message.drop(botCommandPosition).take(128)
        command.isEmpty match {
          case true => {
            Left(botUnicast("You did not give me any instructions :-(", sender))
          }
          case _ => {
            val result = botLang.parse(botLang.language, command)
            result.successful match {
              case true => Right(result.get)
              case _ =>   Left(botUnicast("you gave me an instruction i could not understand understand :-(",sender))
            }
          }
        }
      }else {
        Left(Broadcast(PublicMessage(clientMessage.message, clientMessage.user, clientMessage.autoGenerated)))
      }
    }



  def processParsedQuizMessages(bot: ActorRef)(self: ActorRef)(sender: ActorRef)(message: Any)(implicit ec: ExecutionContext) = {
    implicit val timeout = Timeout(2.seconds)
    message match {
      case nq @ QuizActor.NewQuiz(quizName: String) => {
        bot ! nq
        self ! botBroadcast(s"I created a quiz called --> ${nq.name} <--")
      }
      case aq @ QuizActor.AddQuizQuestion(quizName, question) => {
        val future = bot ? aq
        future.foreach({
          case QuizActor.NoSuchQuiz => self ! botUnicast(s"I could not find a quiz with the name --> ${aq.name} <--", sender)
          case _ => self ! botUnicast(s"I added the question: \n ${aq.question} \n to the quiz  --> ${aq.name} <--", sender)
        })
      }
      case aqa @ QuizActor.AddQuizAnswers(quizName, answers) => {
        val future = bot ? aqa
        future.foreach(msg => {
          msg match {
            case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${aqa.name} <--", sender)
            case _ => {
              val answers_ = aqa.answers.map(triple => {
                val (indicator, answer, bool) = triple
                s"${indicator}: ${answer}\n"
              }) mkString "\n"
              self ! botUnicast(s"I added you answers: ${answers_} to the quiz  --> ${aqa.name} <--", sender)
            }
          }
        })
      }
      case aq @ QuizActor.AnswerQuiz(userName, quizName, usersAnswer) => {
        val future = bot ? aq
        future.foreach({
          case QuizActor.NoSuchQuiz => self ! botUnicast(s"I could not find a quiz with the name --> ${aq.userName} <--", sender)
          case _ => {
            self ! botBroadcast(s"${userName} answered quiz --> ${quizName} <-- with ${usersAnswer}")
          }
        })
      }
      case pq @ QuizActor.PublishQuiz(quizName: String) => ???
      case eq @ QuizActor.EvaluateQuiz(name: String) => ???
      case gpq @ QuizActor.GetPublishedQuizzes => ???
      case gs @ QuizActor.GetScoreboard => ???
    }
  }
  }

