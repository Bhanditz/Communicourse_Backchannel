package CommunicationProtocol

import CommunicationProtocol.Chatroom.{Broadcast, ChatroomMessage}
import Quiz.QuizBotLanguage
import Quiz._
import BotInstructions._
import Traits._
import akka.actor.ActorRef
import akka.pattern.ask
import akka.util.Timeout

import scala.concurrent.duration._
import scala.concurrent.ExecutionContext.Implicits.global._
import scala.util.parsing.combinator._
import scala.collection.immutable.StringOps
import scala.concurrent.{ExecutionContext, Future}
/**
  * Created by robertMueller on 15.02.17.
  */
object Protocol {

  def messageCheck(clientMessage: ClientMessage,botLang: BotLanguage, bot: ActorRef, sender: ActorRef): Either[ChatroomMessage, Any] = {
      val clientMessage_ = clientMessage.copy (message = clientMessage.message + s" me=${clientMessage.user}")
      val botCommandPosition = extractMessageForBotPos(clientMessage.message)
      //evertything after hey_arjen
      if(botCommandPosition >= 0){
        val command =  clientMessage_.message.drop(botCommandPosition).take(128)
        command.isEmpty match {
          case true => {
            Left(botUnicast("You did not give me any instructions :-(", sender))
          }
          case _ => {
            val result = botLang.parse(botLang.language, command)
            result.successful match {
              case true => Right(result.get)
              case _ =>   Left(botUnicast("you gave me an instruction i could not understand understand :-(",sender))
            }
          }
        }
      }else {
        Left(Broadcast(PublicMessage(clientMessage.message, clientMessage.user, clientMessage.autoGenerated)))
      }
    }


  def authorizationCheck(quizName: String, user: String) = ???
  def processParsedQuizMessages(bot: ActorRef)(sender: ActorRef)(message: Any)(implicit ec: ExecutionContext): Future[ChatroomMessage] = {
    implicit val timeout = Timeout(2.seconds)
    message match {
      case nq @ QuizActor.NewQuiz(quizName: String) => {
        bot ! nq
        Future(botBroadcast(s"I created a quiz called --> ${nq.name} <--"))
      }
      case aq @ QuizActor.AddQuizQuestion(quizName, question) => {
        val future = bot ? aq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${aq.name} <--", sender)
          case _ => botUnicast(s"${System.lineSeparator}I added the question: ${System.lineSeparator} ${aq.question} ${System.lineSeparator} to the quiz  --> ${aq.name} <--", sender)
        })
      }
      case aqa @ QuizActor.AddQuizAnswers(quizName, answers) => {
        val future = bot ? aqa
        future.map(msg => {
          msg match {
            case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${aqa.name} <--", sender)
            case _ => {
              val answers_ = aqa.answers.map(triple => {
                val (indicator, answer, bool) = triple
                s"${indicator.fold(_.toString, _.toString)}: ${answer}"
              })
               botUnicast(s"I added your answers:${System.lineSeparator}"
                 + s"${answers_.mkString(System.lineSeparator)} to the quiz  --> ${aqa.name} <--", sender)
            }
          }
        })
      }
      case aq @ QuizActor.AnswerQuiz(userName, quizName, usersAnswer) => {
        val future = bot ? aq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${aq.quizName} <--", sender)
          case _ => {botBroadcast(s"${userName} answered quiz --> ${quizName} <-- with ${usersAnswer.fold(_.toString, _.toString)}")}
        })
      }
      case pq @ QuizActor.PublishQuiz(quizName: String) => {
        val future = bot ? pq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${pq.name} <--", sender)
          case QuizActor.PublishQuizFailure(reason) => {botUnicast(s"There was an error publishing your quiz. Reason: ${reason.toString()}", sender)}
          case QuizActor.QuizSuccess => {botBroadcast(s"A new quiz with the name --> ${quizName} <-- has been published")}
        })
      }
      case eq @ QuizActor.EvaluateQuiz(name: String) => {
        val future = bot ? eq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${eq.name} <--", sender)
          case QuizActor.QuizEvaluationResults(winnerList) => {
            botBroadcast(s"The quiz --> ${name} <-- has been evaluated.\nHere are the winners:\n==========\n${winnerList mkString("\n")}\n==========")
        }
      })}

      case gpq @ QuizActor.GetPublishedQuizzes => {
        val future = bot ? gpq
        future.map({
          case QuizActor.PublishedQuizzes(map) => {
            if(map.isEmpty){
              botUnicast(s"I could not find any published quizzes.", sender)
            } else {
              botUnicast(map.map(_._2._1.toString()).toList.mkString(" "), sender)
            }
          }
        })
      }

      case gs @ QuizActor.GetScoreboard => {
        val future = bot ? gs
        future.map({
          //QuizManager.prettifyScoreboard(scoreboard)
          case QuizActor.Scoreboard(scoreboard) => {
            if(scoreboard.isEmpty) {
              botUnicast("The scoreboard is empty", sender)
            } else {
              botUnicast(QuizManager.prettifyScoreboard(scoreboard),sender)
            }
          }
        })
      }

      //case dq @ QuizActor.RemoveQuiz(quizName: String) => ???

      case pq @ QuizActor.GetPendingQuizzes => {
        val future = bot ? pq
        future.map({
          case QuizActor.PendingQuizzes(pendingQuizzes) => {
            if(pendingQuizzes.isEmpty){
              botUnicast("I cannot find any pending quizzes",sender)
            }
            else {
              botUnicast(pendingQuizzes.map(_._2.run(QuizState())).map(_.toString()).mkString("\n"), sender)
            }
          }
        })
      }
    }
  }
  }

