package CommunicationProtocol

import CommunicationProtocol.BotInstructions._
import CommunicationProtocol.Chatroom.{Broadcast, ChatroomMessage}
import Quiz._
import Traits._
import UserGeneratedInfo.{UserGeneratedInfoActor, ValueProposal}
import akka.actor.ActorRef
import akka.pattern.ask
import akka.util.Timeout

import scala.concurrent.duration._
import scala.concurrent.{ExecutionContext, Future}
/**
  * Created by robertMueller on 15.02.17.
  */
object Protocol {

  def messageCheck(clientMessage: ClientMessage,botLang: BotLanguage, bot: ActorRef, sender: ActorRef): Either[ChatroomMessage, Any] = {
      val clientMessage_ = clientMessage.copy (message = clientMessage.message + s" me=${clientMessage.user}")
      val botCommandPosition = extractMessageForBotPos(clientMessage.message)
      //evertything after hey_arjen
      if(botCommandPosition >= 0){
        val command =  clientMessage_.message.drop(botCommandPosition).take(128)
        command.isEmpty match {
          case true => {
            Left(botUnicast("You did not give me any instructions :-(", sender))
          }
          case _ => {
            val result = botLang.parse(botLang.language, command)
            result.successful match {
              case true => Right(result.get)
              case _ =>   Left(botUnicast("you gave me an instruction i could not understand :-(",sender))
            }
          }
        }
      }else {
        Left(Broadcast(PublicMessage(clientMessage.message, clientMessage.user, clientMessage.autoGenerated)))
      }
    }

  def processValueProposalMessages(bot: ActorRef)(sender: ActorRef)(message: Any)(implicit ec: ExecutionContext): Future[ChatroomMessage] = {
    implicit val timeout = Timeout(2.seconds)
    /*HELPER*/
    def handleResponse(msg: Any): ChatroomMessage = {
      msg match {
        case UserGeneratedInfoActor.GeneratedInfoSuccess => botUnicast("Your operation was successfull.", sender)
        case UserGeneratedInfoActor.AddedProposal(newkey: String, value: String) => botBroadcast(s"I added new information: " +
           s"${System.lineSeparator} ${"="*15} ${System.lineSeparator}  $newkey: $value ${System.lineSeparator} ${"="*15}")
        case UserGeneratedInfoActor.AllProposals(proposals: List[ValueProposal]) => botUnicast(proposals.map(_.toString).mkString(System.lineSeparator),sender)
        case UserGeneratedInfoActor.NoSuchProposal => botUnicast("I cannot find any entries for that name, sorry ;-)", sender)
        case UserGeneratedInfoActor.DeletionRequirementsNotGiven => botUnicast("This information cannot be deleted. The upvote downvote ratio is too high.",sender)
      }
    }
    /*ACTIONS*/
    message match {
      case ap@UserGeneratedInfoActor.AddProposal(proposal: ValueProposal) => {
        val future = bot ? ap
        future.map(handleResponse(_))
      }
      case uv@UserGeneratedInfoActor.Upvote(infoName: String, userName: String) => {
        val future = bot ? uv
        future.map(result => {
          result match {
          case UserGeneratedInfoActor.GeneratedInfoSuccess => botBroadcast(s"$userName just upvoted $infoName.")
          case _ => handleResponse(result)
          }
        })
      }
      case dv@UserGeneratedInfoActor.Downvote(infoName: String, userName: String) =>  {
        val future = bot ? dv
        future.map(result => {
          result match {
            case UserGeneratedInfoActor.GeneratedInfoSuccess => botBroadcast(s"$userName just downvoted $infoName.")
            case _ => handleResponse(result)
          }
        })
      }
      case dp@UserGeneratedInfoActor.DeleteProposal(infoName) => {
        val future = bot ? dp
        future.map(handleResponse(_))
      }
      case gp@UserGeneratedInfoActor.GetAllProposals => {
        val future = bot ? gp
        future.map(handleResponse(_))}
    }


  }


  def authorizationCheck(quizName: String, user: String) = ???
  def processParsedQuizMessages(bot: ActorRef)(sender: ActorRef)(message: Any)(implicit ec: ExecutionContext): Future[ChatroomMessage] = {
    implicit val timeout = Timeout(2.seconds)
    message match {
      case nq @ QuizActor.NewQuiz(quizName: String) => {
        bot ! nq
        Future(botBroadcast(s"I created a quiz called --> ${nq.name} <--"))
      }
      case aq @ QuizActor.AddQuizQuestion(quizName, question) => {
        val future = bot ? aq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${aq.name} <--", sender)
          case _ => botUnicast(s"${System.lineSeparator}I added the question: ${System.lineSeparator} ${aq.question} ${System.lineSeparator} to the quiz  --> ${aq.name} <--", sender)
        })
      }
      case aqa @ QuizActor.AddQuizAnswers(quizName, answers) => {
        val future = bot ? aqa
        future.map(msg => {
          msg match {
            case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${aqa.name} <--", sender)
            case _ => {
              val answers_ = aqa.answers.map(triple => {
                val (indicator, answer, bool) = triple
                s"${indicator.fold(_.toString, _.toString)}: ${answer}"
              })
               botUnicast(s"I added your answers:${System.lineSeparator}"
                 + s"${answers_.mkString(System.lineSeparator)} ${System.lineSeparator} to the quiz  --> ${aqa.name} <--", sender)
            }
          }
        })
      }
      case aq @ QuizActor.AnswerQuiz(userName, quizName, usersAnswer) => {
        val future = bot ? aq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${aq.quizName} <--", sender)
          case _ => {botBroadcast(s"${userName} answered quiz --> ${quizName} <-- with ${usersAnswer.fold(_.toString, _.toString)}")}
        })
      }
      case pq @ QuizActor.PublishQuiz(quizName: String) => {
        val future = bot ? pq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${pq.name} <--", sender)
          case QuizActor.PublishQuizFailure(reason) => {botUnicast(s"There was an error publishing your quiz. Reason: ${reason.toString()}", sender)}
          case QuizActor.QuizSuccess => {botBroadcast(s"A new quiz with the name --> ${quizName} <-- has been published")}
        })
      }
      case eq @ QuizActor.EvaluateQuiz(name: String) => {
        val future = bot ? eq
        future.map({
          case QuizActor.NoSuchQuiz => botUnicast(s"I could not find a quiz with the name --> ${eq.name} <--", sender)
          case QuizActor.QuizEvaluationResults(winnerList) => {
            botBroadcast(s"The quiz --> ${name} <-- has been evaluated.\nHere are the winners:\n==========\n${winnerList mkString("\n")}\n==========")
        }
      })}

      case gpq @ QuizActor.GetPublishedQuizzes => {
        val future = bot ? gpq
        future.map({
          case QuizActor.PublishedQuizzes(map) => {
            if(map.isEmpty){
              botUnicast(s"I could not find any published quizzes.", sender)
            } else {
              botUnicast(map.map(_._2._1.toString()).toList.mkString(" "), sender)
            }
          }
        })
      }

      case gs @ QuizActor.GetScoreboard => {
        val future = bot ? gs
        future.map({
          //QuizManager.prettifyScoreboard(scoreboard)
          case QuizActor.Scoreboard(scoreboard) => {
            if(scoreboard.isEmpty) {
              botUnicast("The scoreboard is empty", sender)
            } else {
              botUnicast(QuizManager.prettifyScoreboard(scoreboard),sender)
            }
          }
        })
      }

      //case dq @ QuizActor.RemoveQuiz(quizName: String) => ???

      case pq @ QuizActor.GetPendingQuizzes => {
        val future = bot ? pq
        future.map({
          case QuizActor.PendingQuizzes(pendingQuizzes) => {
            if(pendingQuizzes.isEmpty){
              botUnicast("I cannot find any pending quizzes",sender)
            }
            else {
              botUnicast("Here are the pending quizzes:" + System.lineSeparator + "="*15+ System.lineSeparator +
                pendingQuizzes.map(q => {
                val (state, quiz) = q._2.run(QuizState())
                s"State: ${System.lineSeparator} ${state.toString} ${quiz.toString}"
              }).mkString(System.lineSeparator), sender)
            }
          }
        })
      }
    }
  }
  }

